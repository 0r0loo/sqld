
-- ()  not   sql연산자비트윈 연산자        맨마지막 and or 
-- ^= <> !=  not


-- team id team name 

SELECT TEAM_ID, TEAM_NAME
	FROM TEAM
		WHERE TEAM_NAME = '드래곤즈';

-- KO2 OR K07

SELECT *
	FROM TEAM
		WHERE TEAM_ID IN ('K02','K07');
	
-- TEAM ID K02는 MF
-- K07 는 DF

SELECT *
	FROM PLAYER
		WHERE TEAM_ID ='K02' AND "POSITION" != 'MF'
		OR
		TEAM_ID = 'K07' AND "POSITION" !='DF';

SELECT *
	FROM PLAYER
		WHERE (TEAM_ID,"POSITION") 
			 IN (('K02','MF') , ('K07', 'DF'));

-- 키 170 이상 180이하

SELECT *
	FROM PLAYER
		WHERE HEIGHT NOT BETWEEN 170 AND 180;

--SQL연산자를 사용하는 이유는 빠름
-- K02 K07 포지션 MF 키는 170이상 180이하 근데 OK

SELECT *
	FROM PLAYER
		WHERE TEAM_ID = 'K02' OR
			  TEAM_ID = 'K07'
			AND
			"POSITION" = 'MF'
			AND
			HEIGHT >= 170
			AND
			HEIGHT <= 180;
	
SELECT *
	FROM PLAYER
		WHERE TEAM_ID IN ('K02','K07')
			AND
			"POSITION" = 'MF'
			AND
			HEIGHT BETWEEN 170 AND 180;



-- 성이 김으로 시작하는사람 찾아라 태규야 네 !
-- 와일드 카드 %는 모두다
-- _ 글자수
SELECT *
	FROM PLAYER
		WHERE PLAYER_NAME LIKE '김';

	
-- ROWNUM

-- paging 10개 !!
-- table seq
-- 고유번호 1 6  10

SELECT ROWNUM, PLAYER.* FROM PLAYER WHERE ROWNUM <= 10;
SELECT ROWNUM, PLAYER.* FROM PLAYER WHERE ROWNUM BETWEEN 2 AND 6;



SELECT SEQ, ID, TITLE, REGDATE FROM
			(SELECT ROWNUM AS RNUM, SEQ, ID, TITLE, REGDATE FROM
				(SELECT SEQ, ID, TITLE, REGDATE FROM MYBOARD ORDER BY REGDATE)
			WHERE ROWNUM < = #{last})
		WHERE RNUM >= #{first}
	
	
SELECT ROWNUM, P2.* FROM
			(SELECT ROWNUM AS RNUM, P.* FROM
				(SELECT * FROM PLAYER ORDER BY PLAYER_ID) P
			WHERE ROWNUM < = 10 ) P2
		WHERE RNUM >= 4
	
-- FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY	
	SELECT * FROM PLAYER ORDER BY PLAYER_ID;
	
	
	SELECT ROWNUM, PLAYER.* FROM PLAYER WHERE ROWNUM < 10 ORDER BY PLAYER_ID;
	



SELECT ROWNUM, P2.* FROM
(SELECT ROWNUM AS RNUM, P.* FROM
(SELECT * FROM EMP ORDER BY SAL DESC) P
	WHERE ROWNUM < =5 ) P2
	WHERE RNUM >=3;



SELECT * FROM 
	(SELECT ROWNUM RN, E.* FROM (SELECT * FROM EMP ORDER BY SAL DESC) E)
		WHERE RN BETWEEN 3 AND 5;
-- 이유 알았고 고쳤음




-- KING FORD SCOTT JONES BLAKE
-- KING SCOTT FORD JONES BLAKE

SELECT --LOWER('LEX'),UPPER(LAST_NAME),SUBSTR(LAST_NAME,4,3),
 --SUBSTR(LAST_NAME,4,3),
-- ASCII(SUBSTR(LAST_NAME,4,1)),
-- LENGTH(FIRST_NAME),
-- TRIM('　　DE HAAN　　'),LENGTH(TRIM('　　DE HAAN　　')),
-- LTRIM('AAAABAAATTTT     ','A'),
-- CONCATENATION
    CONCAT('HAPPY','.COM'), FIRST_NAME||' '||LAST_NAME,
     EMPLOYEES.*
     FROM EMPLOYEES
         WHERE LOWER (FIRST_NAME)=LOWER('LEX');
        
        
        
SELECT LOWER(FIRST_NAME),HR.EMPLOYEES.*
	FROM HR.EMPLOYEES
        
SELECT UPPER(FIRST_NAME),HR.EMPLOYEES.*
	FROM HR.EMPLOYEES;	
	
SELECT SUBSTR(FIRST_NAME,2,4),HR.EMPLOYEES.* -- 컬럼이름 , 인덱스 시작번호(1부터시작), 시작부터몇개?
	FROM HR.EMPLOYEES;		
	
SELECT LENGTH(FIRST_NAME),HR.EMPLOYEES.*
	FROM HR.EMPLOYEES;		
	
SELECT LTRIM('SSSSSSDDDDDSSSSS    ','S'),HR.EMPLOYEES.*
	FROM HR.EMPLOYEES;
	

SELECT TRIM(LEADING 'S' FROM first_name) AS 메롱,HR.EMPLOYEES.*
	FROM HR.EMPLOYEES;

SELECT ASCII('B') FROM HR.EMPLOYEES;

SELECT CONCAT('한','왜') FROM DUAL;
SELECT '아' || '왜' FROM DUAL;


-- 숫자
-- 어렵진 않은데 많이들 틀리더라고
-- 반올림, 올림, 버림(TRUNK)이 핸들링이 까다로움 -> 3.151515 3번째 자리에서 반올림 한 값은 ? 3.152
-- CEIL, FLOOR(얘네만 유념해서 봐주셈)
-- SIGN
-- MOD
SELECT * FROM DUAL; -- 더미 테이블 생성
SELECT TRUNC(3.145), TRUNC(3.145, 2) FROM DUAL;
SELECT ROUND(3.51515), ROUND(3.515156,4) FROM DUAL;
-- CEIL(최근접 최상위 정수값), FLOOR(최근접 최하위 정수값)
SELECT CEIL(3.14), CEIL(-3.14) FROM DUAL;
SELECT FLOOR(3.14), FLOOR(-3.14) FROM DUAL;
SELECT MOD(10,4) FROM DUAL; --10%3;

-- ABS 절대값이다
SELECT ABS(-15) FROM DUAL

-- SIGN 양수인지 음수인지 구별 양수면 1 0이면 0 음수면 -1
SELECT SIGN(-15) FROM DUAL;
SELECT SIGN(0) FROM DUAL;
SELECT SIGN(15) FROM DUAL;

-- MOD 숫자1을 숫자2로 나눠서 나머지를 반환
SELECT MOD(10,4) FROM DUAL

-- CEIL 크거나  같은 최소 정수    가우스함수
SELECT CEIL(-4.123) FROM DUAL;

--FLOOR 숫자보다 작거나 같은 최대 정수
SELECT FLOOR(4.123) FROM DUAL;
SELECT FLOOR(-4.123) FROM DUAL;

--ROUND(숫자 [,M]) 숫자를 소수자 M자리에서 반올림하여 리턴한다
SELECT ROUND(4.125,2) FROM DUAL;

-- TRUNC 숫자를 소수 M자리에서 잘라서 버린다  (숫자 ,M)
SELECT TRUNC(4.123,2) FROM DUAL;


--날짜형
--SYSDATE
SELECT SYSDATE FROM DUAL;

SELECT EXTRACT(YEAR FROM HIREDATE)
	FROM EMP;

SELECT TO_NUMBER(TO_CHAR(HIREDATE, 'YYYY')) 입사년도
FROM EMP;



-- 변환형 함수

SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD') 날짜 FROM EMP;

--6. CASE 표현
SELECT ENAME , sal,
	CASE WHEN SAL >2000
		 THEN SAL
		 ELSE 2000
		 END REVISED_SALARY
	FROM EMP;
-- 2000이상이면 보너스를 1000주고 1000이상이면 500을주고 1000미만이면 주지마
SELECT ENAME , SAL , COMM,
	CASE WHEN SAL>=2000 THEN NVL(COMM,0)+1000
		 WHEN SAL>=1000 THEN NVL(COMM,0)+500
		 WHEN SAL<1000 THEN NVL(COMM,0)
		END 추가보너스		 
	FROM EMP;


-- NULL 관련함수


SELECT COMM
	FROM EMP
	WHERE COMM IS NULL ;












